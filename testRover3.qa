/*
 * SONO PIAGA
 * STO LAVORANDO SU QUESTO FILE ATTUALMENTE PERCHE' STO FACENDO MOLTI ESPERIMENTI SUI RULES
 * LO TERRÒ IN CONSIDERAZIONE PER FUTURI AGGIORNAMENTI MA QUANDO SAPRÒ BENE COME FARE 
 * TORNO A LAVORARE SUL FILE DI PROGETTO PRINCIPALE
 */
 


System testRover3
 
Dispatch robotMoveLeft 		: robotMoveLeft(TIME)
Dispatch robotRotateLeft	: robotRotateLeft(TIME)
Dispatch robotMoveRight 	: robotMoveRight(TIME)
Dispatch robotRotateRight	: robotRotateRight(TIME)
Dispatch robotMoveForward	: robotMoveForward(TIME)
Dispatch robotMoveBackwards	: robotMoveBackwards(TIME)

Event unityAddr				: unityAddr(ADDR)
Event robotHold 			: robotHold(TIME)
Event robotDone				: robotDone(TIME)
Event inputcmd 				: usercmd(executeInput(CMD))
Event usercmd 				: usercmd(robotgui(X))
Event alarm 				: alarm(fire)
Event obstacle 				: obstacle(X)
Event cmd 					: cmd(X)
Event sonarDetect    		: sonarDetect(X)
Event sonar          		: sonar(SONAR, TARGET, DISTANCE)
   
 

Context  ctxRover3  ip [ host="localhost"  port=8070 ] -httpserver    
EventHandler alarmh for alarm -print {memoCurrentEvent -lastonly for highlevel};


QActor movementsregister context ctxRover3 {
	Plan loop normal[
	]
	transition stopAfter 60000
		whenMsg robotMoveForward -> test,
		whenMsg robotMoveBackwards -> test,
		whenMsg robotRotateLeft -> test,
		whenMsg robotRotateRight -> test
	finally repeatPlan
	
	Plan test resumeLastPlan[		
		onMsg robotMoveForward:robotMoveForward(TIME) -> javaRun it.unibo.custom.path.register("robotMoveForward:robotMoveForward", TIME);
		onMsg robotRotateLeft:robotRotateLeft(TIME) -> javaRun it.unibo.custom.path.register("robotRotateLeft:robotRotateLeft", TIME);
		onMsg robotRotateRight:robotRotateRight(TIME) -> javaRun it.unibo.custom.path.register("robotRotateRight:robotRotateRight", TIME); 
		onMsg robotMoveBackwards:robotMoveBackwards(TIME) -> javaRun it.unibo.custom.path.register("robotMoveBackwards:robotMoveBackwards", TIME)
	]
	
}
QActor rover context ctxRover3 {
	//INIZIA ED ASPETTA EVENTI O MESSAGGI
	Rules{
		forTime(T).
	}
	
	Plan loop normal[
	//	javaRun it.unibo.custom.path.testMsg("we");
		forward movementsregister -m robotMoveForward:robotMoveForward(2000);
		delay time(500);
		forward movementsregister -m robotRotateLeft:robotRotateLeft(2000);
		delay time(500);		
		forward movementsregister -m robotRotateRight:robotRotateRight(2000);
		delay time(500);	
		forward movementsregister -m robotMoveBackwards:robotMoveBackwards(2000)
		
	]
	transition stopAfter 60000
		whenEvent unityAddr->doConnectToUnity,
		//whenEvent robotHold:robotHold(TIME) do println("I'm still hold"),
		whenMsg robotMoveForward -> moveForward,
		whenMsg robotMoveBackwards -> moveBackwards,
		whenMsg robotRotateLeft -> rotateLeft,
		whenMsg robotRotateRight -> rotateRight
	finally repeatPlan
	
	Plan doConnectToUnity resumeLastPlan[
		println("connectingToUnity");
		onEvent unityAddr:unityAddr(X)-> actorOp workWithUnity(X);
		actorOp createSimulatedActor   
	]


	//MUOVITI IN AVANTI
	Plan moveForward [
		println("Received forward!");
		forward movementsregister -m robotMoveForward:robotMoveForward(TIME);
		onMsg robotMoveForward:robotMoveForward(TIME) -> addRule timing(TIME);
		[!? timing(TIME)] println(forwardsTime(TIME))
	]
	reactive [!? timing(TIME)] onward 20 time(TIME)
		whenEnd -> endOfStep
		whenTout 100000-> handleTout
		whenEvent robotHold -> endOfMovement
	
	
	//MUOVITI INDIETRO 
	Plan moveBackwards [
		println("Received backward!");
		forward movementsregister -m robotMoveBackwards:robotMoveBackwards(TIME);
		onMsg robotMoveBackwards:robotMoveBackwards(TIME) -> addRule timing(TIME);
		[!? timing(TIME)] println(backwardsTime(TIME))
	]
	reactive [!? timing(TIME)] backwards 20 time(TIME)
		whenEnd -> endOfStep
		whenTout 100000-> handleTout
		whenEvent robotHold -> endOfMovement
	
	Plan rotateLeft [
		println("Received left!");
		forward movementsregister -m robotRotateLeft:robotRotateLeft(TIME);
		onMsg robotRotateLeft:robotRotateLeft(TIME) -> addRule timing(TIME);
		[!? timing(TIME)] println(leftTime(TIME));
		[!? timing(TIME)] left 20 time(TIME)
	]
	transition
		whenTime 450 -> endOfStep
		whenEvent robotHold -> endOfMovement
	
	Plan rotateRight [
		println("Received right!");
		forward movementsregister -m robotRotateRight:robotRotateRight(TIME);
		onMsg robotRotateRight:robotRotateRight(TIME) -> addRule timing(TIME);
		[!? timing(TIME)] println(rightTime(TIME));
		[!? timing(TIME)] right 20 time(TIME)
	]
	transition
		whenTime 450 -> endOfStep
		whenEvent robotHold -> endOfMovement
		
	Plan endOfMovement [
		removeRule timing(TIME);
		onEvent robotHold:robotHold(TIME) -> addRule timing(TIME)
	]
	reactive [!? timing(TIME)] stop 20 time(TIME)
		whenEnd -> endOfStep
		whenTout 100000-> handleTout
		whenEvent robotHold -> handleAlarm
	
	Plan endOfStep [
		println(robotDone);
		[?? timing(TIME)] emit robotDone:robotDone(TIME)
	]
	switchTo loop
	  
	
	
	
	
		
	
	
	
	//PLAN GENERICO PER ERRORI GENERICI DI PROVA
	Plan genericSonar resumeLastPlan[println("WHAT?")]
	//PLAN GENERICO PER QUANDO FINISCE UNA REACTIVE
	Plan endOfWork resumeLastPlan[println("End of work")]
	
	//PLAN GENERICO PER UN TIMEOUTE DI UNA REACTIVE
	Plan handleTout [println("Time out")] switchTo loop
	//PLAN GENERICO PER L'ALLARME
	Plan handleAlarm [println("Alarm fired")]
}   
 
QActor highlevel context ctxRover3{
	
	Rules{
		r2:-startingDistance(S),fCurrentDistance(F),eval(minus,S,F,RV),assert(difference(RV)).
		r3:- difference(DFF).
	}
	
	/*
	 * Parte l'attore di alto livello
	 * Si aspetta solo due comandi:
	 * a) connectToUnity
	 * b) startingDistance
	 * Se si inserisce la starting distance si torna comunque in questo plan
	 * Se si inserisce connectToUnity allora si ha il via per passare all'onSonarLine
	 */
	Plan init normal[
		println("HL: Expecting...");
		println('HL: A) connectToUnity(IP) - connects to unity on ip remote/local pc');
		println('HL: B) startingDistance([Integer]) - choose starting distace from sonar1')
	]
	transition stopAfter 100000
		whenEvent alarm-> handle_alarm,
		whenEvent inputcmd->init_inputcmd
	finally repeatPlan
	
	Plan init_inputcmd resumeLastPlan[
		onEvent inputcmd:X -> println(input_fired(X)); //debug
		
		onEvent inputcmd:usercmd(executeInput(connectToUnity(IP))) -> emit unityAddr:unityAddr(IP);
		onEvent inputcmd:usercmd(executeInput(connectToUnity(IP))) ->{
			addRule unityOn
		};
		
		[?? startingDistance(S)] onEvent inputcmd:usercmd(startingDistance(S)) -> addRule startingDistance(S)
		else onEvent inputcmd:usercmd(startingDistance(S)) -> addRule startingDistance(S)
	]
	switchTo [?? unityOn] onSonarLine
	
	
	
	
	/*
	 *  STAGE 0
	 * 
	 * 	Il rover, appena connesso, è sulla linea di partenza, orientato verso il sonar1 e vicino ad esso.
	 * 	Il rover aspetta un solo comando se non ancora inserito:
	 *  startingDistance([Integer])
	 *  Il compito dello stage0 è di portare il rover al punto di partenza
	 *  Una volta arrivati al punto di partenza, il rover si gira e si cambia stage
	 */
	Plan onSonarLine [
		//DA IMPLEMENTARE
		
		[not !? stepWorkDone]{
			[!? difference(DFF)] {
				[!? difference(DFF)] demo eval(lt,DFF,0);
				[!? goalResult(eval(lt,DFF,0))] {
					[not !? getClose]{
					 	forward rover -m robotMoveForward:robotMoveForward(2000);
					 	println("Getting close");
						addRule getClose 
					 }
				}
				else {
					[not !? getFar]{
						forward rover -m robotMoveBackwards:robotMoveBackwards(2000);
						println("Getting far");
						addRule getFar
					} 
				}
			}
		}
	]
	transition stopAfter 100000
		whenEvent alarm-> handle_alarm,
		whenEvent [not !? stepWorkDone] sonar -> onSonarLine_sonar,
		whenEvent robotDone-> onSonarLine_done,
		whenEvent cmd->onSonarLine_start,
		whenEvent inputcmd -> onSonarLine_inputcmd
	finally repeatPlan
	
	Plan onSonarLine_inputcmd resumeLastPlan[
		onEvent inputcmd:X -> println(input_fired(X)); //debug
		[not !? started] {
			[?? startingDistance(S)] onEvent inputcmd:usercmd(executeInput(startingDistance(S))) -> addRule startingDistance(S)
			else onEvent inputcmd:usercmd(executeInput(startingDistance(S))) -> addRule startingDistance(S);
			
			onEvent inputcmd:usercmd(executeInput(startingDistance(S))) -> {
				[?? stepWorkDone] {
					println("Clearing SP rules");
					removeRule getFar;
					removeRule getClose;
					removeRule difference(DFF)	
				}
			}
		}
	] 
	
	Plan onSonarLine_start resumeLastPlan[
		onEvent cmd:X -> println(X);
		onEvent cmd:cmd(start) -> {
			[not !? stepWorkDone] {
				println("not reached or selected, using actual distance");
				emit robotHold:robotHold(100);
				[!? fCurrentDistance(F)] addRule startingDistance(F);
				[!? startingDistance(S)] println(startingWith(S));
				addRule stepWorkDone
			};
			[?? stepWorkDone] {
				println("reachedPoint");
				forward rover -m robotRotateRight:robotRotateRight(1000);
				addRule started; //QUESTA REGOLA IMPEDISCE LA MODIFICA DELLA STARTING DISTANCE DURANTE L'ESERCIZIO
				addRule run
			}
			
		}
		
	] 
	transition
		whenTime 5000 -> onSonarLine
		whenEvent alarm -> handle_alarm,
		whenEvent robotDone -> stage1
	
	Plan onSonarLine_sonar resumeLastPlan[
		[!? fCurrentDistance(D)] removeRule fCurrentDistance(D);
		[!? difference(DFF)] removeRule difference(DFF);
		
		
		onEvent sonar:sonar(SONAR,rover,DISTANCE) -> addRule fCurrentDistance(DISTANCE);
		[?? sonar2] onEvent sonar:sonar(sonar2,rover,DISTANCE) -> addRule sonar2;
		
		demo r2;
		[!? getClose] {
			[!? difference(DFF)] demo eval(gt,DFF,0);
			[?? goalResult(eval(gt,DFF,0))] {
				[not !? stepWorkDone]{
					addRule stepWorkDone
				};
				
				[?? sonar2] {
					 addRule endOfWork;
					 println("sonar2 eow")
				 }				
			}
		};
		[!? getFar] {
			[!? difference(DFF)] demo eval(lt,DFF,0);
			
			[?? goalResult(eval(lt,DFF,0))]{
				[not !? stepWorkDone]{
					addRule stepWorkDone
				};
				
				[?? sonar2] { 
					addRule endOfWork;
					println("sonar2 eow")
				}
			}
		}
	] switchTo [!? stepWorkDone] onSonarLine_sonar_done
	
	Plan onSonarLine_sonar_done[
		println("sonarLine_sonar done");
		emit robotHold:robotHold(100)
	]
	transition stopAfter 10000
	whenEvent alarm -> handle_alarm,
	whenEvent robotDone-> onSonarLine
	
	
	Plan onSonarLine_done resumeLastPlan[
		removeRule getClose;
		removeRule getFar
	]
	
	
	/*
	 *  STAGE 1
	 *  
	 *  PREMESSA:" Il rover si è portato al punto di partenza, orientato verso il waypoint "
	 *  Il rover si aspetta che l'utente prema il tasto start
	 *  Una volta premuto il tasto start, il rover può incontrare degli ostacoli
	 *  Lo stage1 finisce quando il rover viene individuato dal sonar2
	 */
	
	Plan stage1[
		[?? run]{ 
			println("Going forward with stage1");
			forward rover -m robotMoveForward:robotMoveForward(2000)
		}
	]
	transition stopAfter 25000
		whenEvent alarm-> handle_alarm,
		whenEvent sonar -> stage1_sonar, //SE QUESTO SCATTA E TUTTO VA BENE SI PASSA AL SUCCESSIVO onSonarLine
		whenEvent sonarDetect -> stage1_obstacleAvoidingManagement, //SE QUESTO SCATTA: fixed or dynamic
		whenEvent robotDone->stage1_repeat
	finally repeatPlan
	
	Plan stage1_repeat resumeLastPlan[
		println("Keep going");
		addRule run
	]
	
	Plan stage1_sonar resumeLastPlan[
		[?? fCurrentDistance(F)] onEvent sonar:sonar(sonar2,rover,DISTANCE) -> addRule fCurrentDistance(DISTANCE);
		onEvent sonar:sonar(sonar2,rover,DISTANCE) -> {
			println("Reached to sonar2");
			addRule stepWorkDone
		 } 
	]
	switchTo [?? stepWorkDone] stage1_approachedToSonar2Line
		
	Plan stage1_approachedToSonar2Line[
		println("sonar2 from stage1_sonar");
		emit robotHold:robotHold(500)
	]
	transition stopAfter 10000
		whenEvent alarm->handle_alarm,
		whenEvent robotDone ->stage1_preparingToApproachingEndingPoint
	
	Plan stage1_preparingToApproachingEndingPoint[
		
		
		removeRule getFar;
		removeRule getClose;
		removeRule difference(DFF);
		println("Prepare to ending");
		forward rover -m robotRotateLeft:robotRotateLeft(500)
	]
	transition stopAfter 10000
		whenEvent alarm->handle_alarm,
		whenEvent robotDone -> onSonarLine
	
	/*
	 * Quando sonarDetect scatta significa che il rover ha davanti qualcosa, bisogna capire cos'è
	 * Sappiamo che i fixed object sono oggetti fissi che non si spostano nel tempo
	 * Invece l'oggetto mobile segue un percorso di avanti-indietro con un periodo di 5 secondi
	 * Questo significa che ogni 2.5 secondi l'oggetto dinamico passa dal centro ad un'estremità del suo percorso
	 * e viceversa.
	 * 
	 * Chiedo al rover di aspettare 2 secondi, se scatta di nuovo un sonarDetect dopo 2 secondi sappiamo quindi che
	 * davanti al rover c'è un fixed altrimenti dynamic
	 * 
	 */
	Plan stage1_obstacleAvoidingManagement resumeLastPlan [
		println("obstacleAvoidingManagement");
		addRule run;
		emit robotHold:robotHold(4000)
	]
	transition stopAfter 10000 		
		whenEvent alarm -> handle_alarm,
		whenEvent robotDone -> stage1_evaluateDetection
		
	Plan stage1_evaluateDetection [
		println("Evaluating: done") 
	]
	transition
		whenTime 500 -> stage1
		whenEvent alarm->handle_alarm,
		whenEvent sonarDetect->stage1_managingFixedObject_loop_begin
	
	/*
	 * Se si arriva al plan seguente allora si è di fronte ad una barriera fissa
	 * Si cerca quindi la strada per evitarla.
	 * Bisogna considerare che non si conosce quale barriera fissa si ha davanti
	 * La strategia è quella di muovere il rover a sinistra con la seguente strategia:
	 * loop:-backwards left forward right evaluate
	 * Nel caso in cui, durante il loop ci si ritrova a segnalare sonarDetect significa che siamo in presenza
	 * di un wall laterale e bisogna correggere il tiro e andare a destra invece che a sinistra
	 * 
	 */	
	Plan stage1_managingFixedObject_loop_begin[
		onEvent sonarDetect:sonarDetect(NAME) ->println(detected(NAME));
		forward rover -m robotMoveBackwards:robotMoveBackwards(1000)
	]
	transition stopAfter 10000
		whenEvent alarm->handle_alarm,
		whenEvent robotDone->stage1_managingFixedObject_loop_firstRotation
	
	Plan stage1_managingFixedObject_loop_firstRotation [
		
		[not !? leftEdge] forward rover -m robotRotateLeft:robotRotateLeft(500)
		else forward rover -m robotRotateRight:robotRotateRight(500)
	]
	transition stopAfter 10000
		whenEvent alarm-> handle_alarm,
		whenEvent robotDone -> stage1_managingFixedObject_loop_avoiding
	
	Plan stage1_managingFixedObject_loop_avoiding [
		println("Avoiding fixed obstacle");
		forward rover -m robotMoveForward:robotMoveForward(2000)
	]
	transition
		stopAfter 10000 //DURANTA TRASLAZIONE LATERALE 
		whenEvent alarm->handle_alarm,
		whenEvent [not !? leftEdge] sonarDetect->stage1_managingFixedObject_loop_edgeDetected,
		whenEvent robotDone -> stage1_managingFixedObject_endloop
	finally repeatPlan
	
	Plan stage1_managingFixedObject_loop_edgeDetected [
		println("detecting left edge");
		emit robotHold:robotHold(400);
		addRule edgeDetected;
		[not !? leftEdge]
			addRule leftEdge
		else
			removeRule leftEdge
	] 
	transition stopAfter 10000
		whenEvent alarm->handle_alarm,
		whenEvent robotDone -> stage1_managingFixedObject_loop_edgeDetected_backward //DURATA RETRO-TRASLAZIONE LATERALE POST EDGE DETECTION
	
	Plan stage1_managingFixedObject_loop_edgeDetected_backward [
		forward rover -m robotMoveBackwards:robotMoveBackwards(1000)
	]
	transition
		stopAfter 10000
		whenEvent alarm->handle_alarm,
		whenEvent robotDone -> stage1_managingFixedObject_endloop
	
	Plan stage1_managingFixedObject_endloop[
		
		[?? edgeDetected] { //QUESTO SI VERIFICA SOLO QUANDO SI VA A SINISTRA E SI TROVA UN LEFTEDGE
			[!? leftEdge]	forward rover -m robotRotateRight:robotRotateRight(500)
			else forward rover -m robotRotateLeft:robotRotateLeft(500)
			
			
		}
		else {
			[not !? leftEdge] forward rover -m robotRotateRight:robotRotateRight(500)
			else forward rover -m robotRotateLeft:robotRotateLeft(500) 
		}
		
	]
	transition stopAfter 10000
		whenEvent alarm -> handle_alarm,
		whenEvent robotDone->stage1
	
	
	
		
	
	Plan handle_alarm [
		println("handling alarm")
	]
	Plan handleEnd [
		println("handling end")
	]
	Plan handleTout [
		println("handling tout")
	]
	Plan endOfWork [
		println("Well done, end of work")
	]
	
	
		
	
	
	
}
 


