/*
 * SONO PIAGA
 * STO LAVORANDO SU QUESTO FILE ATTUALMENTE PERCHE' STO FACENDO MOLTI ESPERIMENTI SUI RULES
 * LO TERRÒ IN CONSIDERAZIONE PER FUTURI AGGIORNAMENTI MA QUANDO SAPRÒ BENE COME FARE 
 * TORNO A LAVORARE SUL FILE DI PROGETTO PRINCIPALE
 */
 


System testRover3



 
Dispatch robotMoveLeft 		: robotMoveLeft(TIME)
Dispatch robotRotateLeft	: robotRotateLeft(TIME)
Dispatch robotMoveRight 	: robotMoveRight(TIME)
Dispatch robotRotateRight	: robotRotateRight(TIME)
Dispatch robotMoveForward	: robotMoveForward(TIME)
Dispatch robotMoveBackwards	: robotMoveBackwards(TIME)

Event unityAddr				: unityAddr(ADDR)
Event robotHold 			: robotHold(TIME)
Event inputcmd 				: usercmd(executeInput(CMD))
Event usercmd 				: usercmd(robotgui(X))
Event alarm 				: alarm(fire)
Event obstacle 				: obstacle(X)
Event cmd 					: cmd(X)
Event sonarDetect    		: sonarDetect(X)
Event sonar          		: sonar(SONAR, TARGET, DISTANCE)
   
 

Context  ctxRover3  ip [ host="localhost"  port=8070 ] -httpserver    
EventHandler evh for  robotHold {memoCurrentEvent for  rover};


QActor rover context ctxRover3 {
	//INIZIA ED ASPETTA EVENTI O MESSAGGI
	Rules{
		forTime(T).
	}
	
	Plan loop normal[
		println("lowlevel ready")
	]
	transition stopAfter 60000
		whenEvent unityAddr->doConnectToUnity,
		whenEvent robotHold:robotHold do println("I'm not doing anything"),
		whenMsg robotMoveForward -> moveForward,
		whenMsg robotMoveBackwards -> moveBackwards,
		whenMsg robotRotateLeft -> rotateLeft,
		whenMsg robotRotateRight -> rotateRight
	finally repeatPlan
	
	
	Plan doConnectToUnity resumeLastPlan[
		println("connectingToUnity");
		onEvent unityAddr:unityAddr(X)-> actorOp workWithUnity(X);
		actorOp createSimulatedActor
		
	] switchTo rotateRight


	//MUOVITI IN AVANTI
	Plan moveForward resumeLastPlan[
		println("Moving forward");
		addRule translation;
		onMsg robotMoveForward:robotMoveForward(T) -> addRule timing(T);
		[!? timing(T)] println(forwardTiming(T))
	]
	reactive [?? timing(T)] onward 25 time(T)
		whenEnd -> endOfMovement
		whenTout 100000-> handleTout
		whenEvent robotHold -> endOfMovement
		
	
	
	//MUOVITI INDIETRO
	Plan moveBackwards resumeLastPlan[
		println("Moving backwards");
		addRule translation;
		onMsg robotMoveBackwards:robotMoveBackwards(T) -> addRule timing(T);
		[!? timing(T)] println(backwardsTiming(T))
		
	]
	reactive [?? timing(T)]  backwards 30 time (T)
		whenEnd -> endOfStep
		whenTout 100000-> handleTout
		whenEvent robotHold -> endOfMovement
		
	Plan rotateLeft resumeLastPlan[
		println("Rotating Left");
		left 50 time (1000)
	] switchTo endOfStep
	
	Plan rotateRight resumeLastPlan[
		println("Rotating Right");
		right 50 time(1000)
	] switchTo endOfStep
	
	/*Plan moveLeft resumeLastPlan[
		println("Moving left");
		left 50 time(1000);
		addRule leftMovement;
		addRule translation
	] switchTo moveForward
	
		
	Plan moveRight resumeLastPlan[
		println("Moving right");
		right 50 time(1000);
		addRule rightMovement;
		addRule translation
	] switchTo moveForward
	*/
	
	
	Plan endOfStep resumeLastPlan[
		
		[?? translation] delay 100
	]
	
		
	Plan endOfMovement[
		onEvent robotHold:X -> println("robot hold called");
		stop 100 time (10);
		[?? leftMovement] right 50 time(1000);
		[?? rightMovement] left 50 time(1000)
		
		
		 
	]
	switchTo loop
	
	//PLAN GENERICO PER ERRORI GENERICI DI PROVA
	Plan genericSonar resumeLastPlan[println("WHAT?")]
	//PLAN GENERICO PER QUANDO FINISCE UNA REACTIVE
	Plan endOfWork resumeLastPlan[println("End of work")]
	
	//PLAN GENERICO PER UN TIMEOUTE DI UNA REACTIVE
	Plan handleTout resumeLastPlan[println("Time out")]
	//PLAN GENERICO PER L'ALLARME
	Plan handleAlarm resumeLastPlan[println("Alarm fired")] switchTo endOfMovement
}   
 
QActor highlevel context ctxRover3{
	
	Rules{
		
		status:- stage(S).
		r1:-assign(startingDistance,10),assign(x,0),getVal(startingDistance,V2),getVal(x,V1),eval(minus,V1,V2,RV),actorPrintln(r1(RV)).
		r2:-startingDistance(S),fCurrentDistance(F),eval(minus,S,F,RV),assert(difference(RV)).
		r3:- difference(DFF).
	}
	
	/*
	 * Parte l'attore di alto livello
	 * Si aspetta solo due comandi:
	 * a) connectToUnity
	 * b) startingDistance
	 * Se si inserisce la starting distance si torna comunque in questo plan
	 * Se si inserisce connectToUnity allora si ha il via per passare all'onSonarLine
	 */
	Plan init normal[
		println("HL: Expecting...");
		println('HL: A) connectToUnity(IP) - connects to unity on ip remote/local pc');
		println('HL: B) startingDistance([Integer]) - choose starting distace from sonar1')
	]
	transition stopAfter 100000
		whenEvent alarm-> handle_alarm,
		whenEvent inputcmd->init_inputcmd
	finally repeatPlan
	
	Plan init_inputcmd resumeLastPlan[
		onEvent inputcmd:X -> println(input_fired(X)); //debug
		
		onEvent inputcmd:usercmd(executeInput(connectToUnity(IP))) -> emit unityAddr:unityAddr(IP);
		onEvent inputcmd:usercmd(executeInput(connectToUnity(IP))) -> addRule unityOn;
		
		[?? startingDistance(S)] onEvent inputcmd:usercmd(startingDistance(S)) -> addRule startingDistance(S)
		else onEvent inputcmd:usercmd(startingDistance(S)) -> addRule startingDistance(S)
	]
	switchTo [?? unityOn] onSonarLine
	
	/*
	 *  STAGE 0
	 * 
	 * 	Il rover, appena connesso, è sulla linea di partenza, orientato verso il sonar1 e vicino ad esso.
	 * 	Il rover aspetta un solo comando se non ancora inserito:
	 *  startingDistance([Integer])
	 *  Il compito dello stage0 è di portare il rover al punto di partenza
	 *  Una volta arrivati al punto di partenza, il rover si gira e si cambia stage
	 */
	Plan onSonarLine [
		//DA IMPLEMENTARE
		
		
	]
	transition stopAfter 100000
		whenEvent alarm-> handle_alarm,
		whenEvent inputcmd -> onSonarLine_inputcmd,
		whenEvent cmd->onSonarLine_start,
		whenEvent sonar -> onSonarLine_sonar
	finally repeatPlan
	
	Plan onSonarLine_inputcmd resumeLastPlan[
		onEvent inputcmd:X -> println(input_fired(X)); //debug
		
		[?? startingDistance(S)] onEvent inputcmd:usercmd(startingDistance(S)) -> addRule startingDistance(S)
		else onEvent inputcmd:usercmd(startingDistance(S)) -> addRule startingDistance(S)
	]
	
	Plan onSonarLine_start resumeLastPlan[
		onEvent cmd:cmd(start) -> {
			addRule start
		}
	] switchTo [!? start] stage1
	
	Plan onSonarLine_sonar resumeLastPlan[
		[!? fCurrentDistance(D)] removeRule fCurrentDistance(D);
		[!? difference(DFF)] removeRule difference(DFF);
		[!? sonarName(SONAR)] removeRule sonarName(SONAR);
		 
		onEvent sonar:sonar(SONAR,rover,DISTANCE) -> addRule fCurrentDistance(DISTANCE);
		onEvent sonar:sonar(SONAR,rover,DISTANCE) -> addRule sonarName(SONAR);
		demo r2;
		[!? difference(DFF)] println(snrDifference(DFF));
		[!? getClose] {
			[!? difference(DFF)] demo eval(gt,DFF,0);
			[?? goalResult(eval(gt,DFF,0))] {
				forward rover -m robotHold:robotHold(100);
				[?? sonarName(sonar2)] addRule endOfWork				
			}
		};
		[!? getFar] {
			[!? difference(DFF)] demo eval(lt,DFF,0);
			[?? goalResult(eval(lt,DFF,0))]{
				forward rover -m robotHold:robotHold(100);
				[?? sonarName(sonar2)] addRule endOfWork
			}
		}
	]
	transition [?? endOfWork] whenTime 500 -> endOfWork  
	
	/*
	 *  STAGE 1
	 *  
	 *  PREMESSA:" Il rover si è portato al punto di partenza, orientato verso il waypoint "
	 *  Il rover si aspetta che l'utente prema il tasto start
	 *  Una volta premuto il tasto start, il rover può incontrare degli ostacoli
	 *  Lo stage1 finisce quando il rover viene individuato dal sonar2
	 */
	
	Plan stage1[
		//DA IMPLEMENTARE
		[!? start] {
			forward rover -m robotMoveForward:robotMoveForward(10000)
		}
	]
	transition stopAfter 100000
		whenEvent alarm-> handle_alarm,
		whenEvent sonar -> stage1_sonar, //SE QUESTO SCATTA E TUTTO VA BENE SI PASSA AL SUCCESSIVO onSonarLine
		whenEvent sonarDetect -> stage1_obstacleAvoidingManagement //SE QUESTO SCATTA: fixed or dynamic
	finally repeatPlan
	
	Plan stage1_sonar resumeLastPlan[
		[?? fCurrentDistance(F)] onEvent sonar:sonar(sonar2,rover,DISTANCE) -> addRule fCurrentDistance(DISTANCE);
		onEvent sonar:sonar(sonar2,rover,DISTANCE) -> {
			 forward rover -m robotHold:robotHold(1000);
			 forward rover -m robotRotateLeft:robotRotateLeft(1000);
			 addRule stepWorkDone
		 } 
		
	] switchTo [?? stepWorkDone] onSonarLine 
	
	/*
	 * Quando sonarDetect scatta significa che il rover ha davanti qualcosa, bisogna capire cos'è
	 * Sappiamo che i fixed object sono oggetti fissi che non si spostano nel tempo
	 * Invece l'oggetto mobile segue un percorso di avanti-indietro con un periodo di 5 secondi
	 * Questo significa che ogni 2.5 secondi l'oggetto dinamico passa dal centro ad un'estremità del suo percorso
	 * e viceversa.
	 * 
	 * Chiedo al rover di aspettare 2 secondi, se scatta di nuovo un sonarDetect dopo 2 secondi sappiamo quindi che
	 * davanti al rover c'è un fixed altrimenti dynamic
	 * 
	 */
	Plan stage1_obstacleAvoidingManagement [
		forward rover -m robotHold:robotHold(100)
	]
	transition 
		whenTime 100 -> stage1
		whenEvent alarm -> handle_alarm,
		whenEvent sonarDetect-> stage1_handleDetection
	finally repeatPlan
	
	
	 
	Plan stage1_handleDetection [
		//HO TROVATO DAVANTI A ME UN OGGETTO E DEVO CHIEDERMI SE È FIXED O DYNAMIC
		//ASPETTO QUINDI 2 SECONDI
		println("Evaluating: waiting")
	]
	transition
		whenTime 2000 -> stage1_evaluateDetection
		whenEvent alarm -> handle_alarm
	
	
	Plan stage1_evaluateDetection [
		//HO ASPETTATO 2 SECONDI
		//SE L'ALLARME SCATTA DI NUOVO ALLORA SIAMO DI FRONTE A
		println("Evaluating: done") 
	]
	transition
		whenTime 500 -> stage1_obstacleAvoidingManagement
		whenEvent sonarDetect->stage1_managingFixedObject_startloop
	
	/*
	 * Se si arriva al plan seguente allora si è di fronte ad una barriera fissa
	 * Si cerca quindi la strada per evitarla.
	 * Bisogna considerare che non si conosce quale barriera fissa si ha davanti
	 * La strategia è quella di muovere il rover a sinistra con la seguente strategia:
	 * loop:-left forward right evaluate
	 * Nel caso in cui, durante il loop ci si ritrova a segnalare sonarDetect significa che siamo in presenza
	 * di un wall laterale e bisogna correggere il tiro e andare a destra invece che a sinistra
	 * 
	 */	
	Plan stage1_managingFixedObject_startloop [
		[not !? leftEdge] forward rover -m robotRotateLeft:robotRotateLeft(500)
		else forward rover -m robotRotateRight:robotRotateRight(500)
	]
	transition
		whenTime 500 -> stage1_managingFixedObject_bodyloop
		whenEvent alarm-> handle_alarm
	finally repeatPlan
	
	Plan stage1_managingFixedObject_bodyloop [
		[not !? leftEdgeDetected] forward rover -m robotMoveForward:robotMoveForward(2000)
	]
	transition
		whenTime 2000->stage1_managingFixedObject_endloop
		whenEvent alarm->handle_alarm,
		whenEvent sonarDetect:sonarDetect(X) do { //QUESTO DEVE CHIAMARE ESCLUSIVAMENTE IN PRESENZA DI EDGE SINISTRO
			forward rover -m robotHold:robotHold(1000);
			addRule leftEdgeDetected
		}
	finally repeatPlan
	
	Plan stage1_managingFixedObject_endloop[
		[?? leftEdgeDetected] { //QUESTO SI VERIFICA SOLO QUANDO SI VA A SINISTRA E SI TROVA UN LEFTEDGE
			forward rover -m robotRotateRight:robotRotateRight(500);
			addRule leftEdge
		}
		else {
			[not !? leftEdge] forward rover -m robotRotateRight:robotRotateRight(500)
			else forward rover -m robotRotateLeft:robotRotateLeft(500) 
		}
	]
	transition
		whenTime 500->stage1_obstacleAvoidingManagement
		whenEvent alarm -> handle_alarm
	
	
	
		
	
	Plan handle_alarm [
		println("handling alarm")
	]
	
	Plan handleEnd [
		println("handling end")
	]
	Plan handleTout [
		println("handling tout")
	]
	
	Plan endOfWork [
		println("Well done, end of work")
	]
	
	
		
	
	
	
}
 


