System testRover4

Event cmd : cmd(X)
Event inputcmd : usercmd(executeInput(X))
Event usercmd : usercmd(robotgui(X))
Event sonar : sonar(SONARNAME, TARGETNAME, DISTANCE)
Event sonarDetect : sonarDetect(X) // sonar on rover
Event alarm : alarm(X)

Event unityAddr : unityAddr(X)
Event startDistance : startDistance(X)
Event sonarDistance : sonarDistance( SONARID, DISTANCE )
Event robotControl : robotControl(X)

Dispatch moveRover : cmd( CMD )

Context ctxRover4 ip [ host="localhost" port=8090 ] -httpserver

EventHandler evh for  sonar { 
	memoCurrentEvent -lastonly for sonarhandler
};

QActor sonarhandler context ctxRover4 {
	Rules{   
		lastSonarData( SONARID ):-
 			retract( msg(M,EV,EMITTER,none,sonar(SONARID,TARGET,DISTANCE),N) ),
 			// actorPrintln( sonar(SONARID,TARGET,DISTANCE) ),
			replaceRule(  sonardata( sonar(SONARID,_,_)  ),
				          sonardata( sonar(SONARID,TARGET,DISTANCE)  )
			),
			lastSonarData(SONARID).
		lastSonarData( SONARID ).
		
		updateSonarData :-
			lastSonarData(sonar1),
			lastSonarData(sonar2).
			
		isnear(SONARID,DISTANCE) :- 
			sonardata( sonar(SONARID,TARGET,DISTANCE) ),			
			//actorPrintln( isnearrrr(SONARID,DISTANCE) ),
			eval( lt, DISTANCE, 40).
			//actorPrintln( isnear(SONARID,DISTANCE) ).
			
		updateStartingDistance(DISTANCE) :-
			replaceRule( startingDistance(_),
						 startingDistance(DISTANCE) ).

		isnearer(SONARID) :-
			sonardata( sonar(SONARID,TARGET,DISTANCE) ),
			startingDistance(GOALDISTANCE),
			eval( lt, DISTANCE, GOALDISTANCE),
			eval( minus, GOALDISTANCE, DISTANCE, R ),
			eval( gt, R, 2).
			//actorPrintln( isnearer(SONARID) ).
			
		isfarther(SONARID) :-
			sonardata( sonar(SONARID,TARGET,DISTANCE) ),
			startingDistance(GOALDISTANCE),
			eval( gt, DISTANCE, GOALDISTANCE),
			eval( minus, DISTANCE, GOALDISTANCE, R ),
			eval( gt, R, 2).
			//actorPrintln( isfarther(SONARID) ).
			
		isatdistance(SONARID) :-
			sonardata( sonar(SONARID,TARGET,DISTANCE) ),
			startingDistance(GOALDISTANCE),
			eval( minus, GOALDISTANCE, 2, LOWERTHREASHOLD ),
			eval( plus, GOALDISTANCE, 2, UPPERTHREASHOLD ),
			eval( gt, DISTANCE, LOWERTHREASHOLD ),
			eval( lt, DISTANCE, UPPERTHREASHOLD ).
			//actorPrintln( isatdistance(SONARID) ).
			
		isatdistance2(SONARID) :-
			retract( msg(M,EV,EMITTER,none,sonar(SONARID,TARGET,DISTANCE),N) ),
			startingDistance(GOALDISTANCE),
			eval( minus, GOALDISTANCE, 2, LOWERTHREASHOLD ),
			eval( plus, GOALDISTANCE, 2, UPPERTHREASHOLD ),
			eval( gt, DISTANCE, LOWERTHREASHOLD ),
			eval( lt, DISTANCE, UPPERTHREASHOLD ).
			//actorPrintln( isatdistance(SONARID) ).
			
		hasreached(SONARID) :-
			sonardata( sonar(SONARID,TARGET,DISTANCE) ).
			
		isfinal :-
			changeDistance,
			finalDistance.
	}
	
	Plan init normal
		actions [
			
		]
		switchTo handleEvents
	
	Plan handleEvents
		actions[   	
		]
	    transition 
			whenTime 60000 -> handleTout,
	    	whenEvent sonar -> processSonarData,
	    	whenEvent startDistance -> setStartDistance,
	    	whenEvent alarm -> handleAlarm,
	    	whenEvent robotControl -> handleControl
	   	finally repeatPlan
		
	Plan setStartDistance resumeLastPlan
		actions [
			println("setStartDistance");
			removeRule startingDistance(X);
			onEvent startDistance : startDistance(X) -> addRule startingDistance(X)
		]
   	
   	Plan processSonarData resumeLastPlan
	   	actions[
	   		demo updateSonarData
	   	]
   		switchTo checkDistance 
    
    Plan checkDistance resumeLastPlan
    actions[
   		//[ !? isnear(sonar1,D)  ] emit sonarObstacle : sonarObstacle(sonar1,D) ;
   		//[ !? isnear(sonar2,D)  ] emit sonarObstacle : sonarObstacle(sonar2,D) ;
   		//[ !? isfarther(sonar1) ] forward rover -m moveRover : cmd(move("forward",40,0)) ;
   		//[ !? isnearer(sonar1)  ] forward rover -m moveRover : cmd(move("backward",40,0)) ;
   		
   		// Se manca startingDistance ovvero al primo avvio, impostalo al valore attuale rilevato
   		[ not !? startingDistance(X) ] onEvent sonar : sonar(sonar1,TARGET,DISTANCE) -> addRule startingDistance(DISTANCE);
   		
   		// Siamo davanti al sonar1 ?
   		onEvent sonar : sonar(sonar1,TARGET,DISTANCE) -> {
   			//println("On sonar1 line");
   			[ not !? started ] {
	   			[ !? isatdistance(sonar1) ] { // Siamo alla distanza corretta? 
	   				//println("On right distance");
	   				[ ?? adjustingDistance ] { // Se il rover si sta muovendo gestito dal sonar, fermiamolo 
	   					forward rover -m moveRover : cmd(move("stop",40,0,1));
	   					println("Distance from sonar1 reached.")
	   				}
	   			} else {
	   				//println("Not on right distance");
	   				[ not !? adjustingDistance ] { // Il rover parte non gestito dal sonar, prendiamone possesso
						[ !? isfarther(sonar1) ] forward rover -m moveRover : cmd(move("forward",20,0,1));
	      				[ !? isnearer(sonar1) ] forward rover -m moveRover : cmd(move("backward",20,0,1));
						addRule adjustingDistance;
						println("Started distance adjustement...")
	   				}
	   			}
   			}
   		} else {
   		
	   		onEvent sonar : sonar(sonar2,TARGET,DISTANCE) -> {
	   			//println("On sonar2 line");
	   			[ !? isatdistance(sonar2) ] {
	   				[ ?? adjustingDistance ] {
	   					forward rover -m moveRover : cmd(move("stop",40,0));
	   					println("Distance from sonar2 reached.")
	   				} else {
	   					emit robotControl : robotControl(sonar2); // FERMATI!!!
	   					forward rover -m moveRover : cmd(move("left",40,1000))
	   				};
	   				emit robotControl : robotControl(finish);
	   				endQActor "[sonarhandler] Finished! Shutdown."
	   			} else {
	   				[ not !? adjustingDistance ] {
	   					emit robotControl : robotControl(sonar2); // FERMATI!!!
	   					forward rover -m moveRover : cmd(move("left",40,1000));
						[ !? isfarther(sonar2) ] forward rover -m moveRover : cmd(move("forward",20,0));
						[ !? isnearer(sonar2) ] forward rover -m moveRover : cmd(move("backward",20,0));
						addRule adjustingDistance;
						println("Started distance adjustement...")
	   				}
	   			}
	   		} else {
	   			[ ?? adjustingDistance ] { // Il sonar ha il controllo del rover ma non lo rileva, siamo finiti fuori dal suo campo
	   				forward rover -m moveRover : cmd(move("stop",100,0));
	   				forward rover -m moveRover : cmd(move("right",40,1000));
	   				forward rover -m moveRover : cmd(move("backward",1,0));
	   				println("Too fast too furious!")
	   			}
	   		}
 
   		}
   	]
   	
   	Plan handleTout resumeLastPlan
   		actions []
   		
   	Plan handleAlarm resumeLastPlan
   		actions [
   			onEvent alarm : alarm(fire) -> {
   				[ ?? adjustingDistance] println("[sonarhandler] detected fire alarm while I had control, cleared out.")
   			}
   		]
   		
   	Plan handleControl resumeLastPlan
   		actions [
   			onEvent robotControl : robotControl(start) -> addRule started;
   			onEvent robotControl : robotControl(finish) -> endQActor "[sonarhandler] Finish event detected! Shutdown."
   		]
}

QActor rover context ctxRover4 {

	Plan init normal
		actions [
			println("Rover started!")
		]
		switchTo handleCommands
	
	Plan handleCommands
		actions [
			
		]
		transition 
			whenTime 60000 -> handleTout,
			whenEvent unityAddr -> connectToUnity,
			whenEvent alarm -> handleAlarm,
			whenEvent robotControl -> handleControl,
			whenMsg moveRover -> execMove
		finally repeatPlan
		
	Plan connectToUnity resumeLastPlan 
		actions [
			memoCurrentEvent;
			[!? unityOn] println("Unity is already connected") 
			else {
				onEvent unityAddr:unityAddr(X) -> connectUnity "X";
				actorOp createSimulatedActor;
				//javaRun it.unibo.custom.path.createRover();
				
				addRule unityOn
			}
		]
			
	Plan execMove resumeLastPlan
		actions [
			onMsg moveRover : cmd(move("forward",SPEED,DURATION)) -> onward 20 time (0);
			onMsg moveRover : cmd(move("forward",SPEED,DURATION,REGISTER)) -> onward 20 time (0);
			onMsg moveRover : cmd(move("forward",SPEED,DURATION,1)) -> javaRun it.unibo.custom.path.register("forward", DURATION);
			onMsg moveRover : cmd(move("backward",SPEED,DURATION)) -> backwards 20 time (0);
			onMsg moveRover : cmd(move("backward",SPEED,DURATION,REGISTER)) -> backwards 20 time (0);
			onMsg moveRover : cmd(move("backward",SPEED,DURATION,1)) -> javaRun it.unibo.custom.path.register("backward", DURATION);
			onMsg moveRover : cmd(move("stop",SPEED,DURATION)) -> stop 20 time (750);
			onMsg moveRover : cmd(move("stop",SPEED,DURATION,REGISTER)) -> stop 20 time (750);
			onMsg moveRover : cmd(move("stop",SPEED,DURATION,1)) -> javaRun it.unibo.custom.path.register("stop", DURATION);
			onMsg moveRover : cmd(move("left",SPEED,DURATION)) -> left 20 time (750);
			onMsg moveRover : cmd(move("left",SPEED,DURATION,REGISTER)) -> left 20 time (750);
			onMsg moveRover : cmd(move("left",SPEED,DURATION,1)) -> javaRun it.unibo.custom.path.register("left", DURATION);
			onMsg moveRover : cmd(move("right",SPEED,DURATION)) -> right 20 time (750);
			onMsg moveRover : cmd(move("right",SPEED,DURATION,REGISTER)) -> right 20 time (750);
			onMsg moveRover : cmd(move("right",SPEED,DURATION,1)) -> javaRun it.unibo.custom.path.register("right", DURATION);
			
			onMsg moveRover : cmd(X) -> println(X)
		]
		

	
	Plan handleTout resumeLastPlan
		actions [
			println("Time out")
		]
		
	Plan handleSonar resumeLastPlan
		actions [
			println("handleSonar")
			/*onEvent sonarDetect : sonarDetect(X) -> {
				stop 40 time (0);
				backwards 40 time (500);
				right 40 time (500);
				onward 40 time (500);
				left 40 time (500);
				onward 40 time (0)
			}*/
		]
		
	Plan handleAlarm resumeLastPlan
		actions [
			println("[rover] Alarm detected! Halting");
			stop 40 time (0)
		]
		
	Plan handleControl resumeLastPlan
		actions [
			println("[rover] External control event! Halting");
			stop 40 time (0);
			onEvent robotControl : robotControl(finish) -> endQActor "[rover] Finish event detected! Shutdown."
		]
		
	Plan endOfMove resumeLastPlan [ println("endOfMove") ]
}

QActor rovermind context ctxRover4 {
	Plan init normal
		actions [
			println("Rover mind started")
		]
		switchTo handleCommands
	
	Plan handleCommands
		actions [
			
		]
		transition
			whenTime 60000 -> handleTout,
			whenEvent robotControl -> handleRobotControl
		finally repeatPlan
		
	Plan handleRobotControl resumeLastPlan
		actions [
			onEvent robotControl : robotControl(start) -> {
				addRule run;
				forward rover -m moveRover : cmd(move("right",40,750,1))
			}
		]
		switchTo [ !? run ] stage1
		
		/*
	 *  STAGE 1
	 *  
	 *  PREMESSA:" Il rover si è portato al punto di partenza, orientato verso il waypoint "
	 *  Il rover si aspetta che l'utente prema il tasto start
	 *  Una volta premuto il tasto start, il rover può incontrare degli ostacoli
	 *  Lo stage1 finisce quando il rover viene individuato dal sonar2
	 */
	
	Plan stage1[
		[?? run]{ 
			println("Going forward with stage1");
			forward rover -m moveRover : cmd(move("forward",20,0,1))
		}
	]
	transition stopAfter 25000
		whenEvent alarm-> handleAlarm,
		whenEvent robotControl -> handleControl,
		whenEvent sonarDetect -> stage1_obstacleAvoidingManagement //SE QUESTO SCATTA: fixed or dynamic

	finally repeatPlan
	
	Plan stage1_repeat resumeLastPlan[
		println("Keep going");
		addRule run
	]

	/*
	 * Quando sonarDetect scatta significa che il rover ha davanti qualcosa, bisogna capire cos'è
	 * Sappiamo che i fixed object sono oggetti fissi che non si spostano nel tempo
	 * Invece l'oggetto mobile segue un percorso di avanti-indietro con un periodo di 5 secondi
	 * Questo significa che ogni 2.5 secondi l'oggetto dinamico passa dal centro ad un'estremità del suo percorso
	 * e viceversa.
	 * 
	 * Chiedo al rover di aspettare 2 secondi, se scatta di nuovo un sonarDetect dopo 2 secondi sappiamo quindi che
	 * davanti al rover c'è un fixed altrimenti dynamic
	 * 
	 */
	Plan stage1_obstacleAvoidingManagement resumeLastPlan [
		println("obstacleAvoidingManagement");
		addRule run;
		forward rover -m moveRover : cmd(move("stop",20,0,1))
	]
	transition
		whenTime 1500 -> stage1_evaluateDetection,
		whenEvent alarm->handleAlarm
		
	Plan stage1_evaluateDetection [
		println("Evaluating: done") 
	]
	transition
		whenTime 500 -> stage1,
		whenEvent alarm->handleAlarm,
		whenEvent sonarDetect->stage1_obstacleAvoidingManagement2ndPass
		
	Plan stage1_obstacleAvoidingManagement2ndPass resumeLastPlan [
		println("obstacleAvoidingManagement2ndPass")
	]
	transition
		whenTime 1000 -> stage1_evaluateDetection2ndPass,
		whenEvent alarm->handleAlarm
		
	Plan stage1_evaluateDetection2ndPass [
		println("Evaluating 2nd pass: done") 
	]
	transition
		whenTime 500 -> stage1,
		whenEvent alarm->handleAlarm,
		whenEvent sonarDetect->stage1_managingFixedObject_loop_begin
	
	/*
	 * Se si arriva al plan seguente allora si è di fronte ad una barriera fissa
	 * Si cerca quindi la strada per evitarla.
	 * Bisogna considerare che non si conosce quale barriera fissa si ha davanti
	 * La strategia è quella di muovere il rover a sinistra con la seguente strategia:
	 * loop:-backwards left forward right evaluate
	 * Nel caso in cui, durante il loop ci si ritrova a segnalare sonarDetect significa che siamo in presenza
	 * di un wall laterale e bisogna correggere il tiro e andare a destra invece che a sinistra
	 * 
	 */	
	Plan stage1_managingFixedObject_loop_begin[
		onEvent sonarDetect:sonarDetect(NAME) ->println(detected(NAME));
		forward rover -m moveRover : cmd(move("backward",20,1000,1))
	]
	transition 
		whenTime 1000 -> stage1_managingFixedObject_loop_firstRotation,
		whenEvent alarm -> handleAlarm,
		whenEvent robotControl -> handleControl
	
	Plan stage1_managingFixedObject_loop_firstRotation [
		
		[not !? leftEdge] forward rover -m moveRover : cmd(move("left",40,750,1))
		else forward rover -m moveRover : cmd(move("right",40,750,1))
	]
	switchTo stage1_managingFixedObject_loop_avoiding
	
	Plan stage1_managingFixedObject_loop_avoiding [
		println("Avoiding fixed obstacle");
		forward rover -m moveRover : cmd(move("forward",20,0,1))
	]
	transition
		whenTime 2000 -> stage1_managingFixedObject_endloop,
		whenEvent alarm->handleAlarm,
		whenEvent [not !? leftEdge] sonarDetect->stage1_managingFixedObject_loop_edgeDetected,
		whenEvent robotControl -> handleControl
	finally repeatPlan
	
	Plan stage1_managingFixedObject_loop_edgeDetected [
		println("detecting left edge");
		forward rover -m moveRover : cmd(move("stop",40,0,1));
		addRule edgeDetected;
		[not !? leftEdge]
			addRule leftEdge
		else
			removeRule leftEdge
	] 
	transition
		whenTime 400 -> stage1_managingFixedObject_loop_edgeDetected_backward //DURATA RETRO-TRASLAZIONE LATERALE POST EDGE DETECTION
		whenEvent alarm -> handleAlarm
	
	Plan stage1_managingFixedObject_loop_edgeDetected_backward [
		forward rover -m moveRover : cmd(move("backward",20,1000,1))
	]
	transition
		whenTime 1000 -> stage1_managingFixedObject_endloop,
		whenEvent alarm -> handleAlarm,
		whenEvent robotControl -> handleControl
	
	Plan stage1_managingFixedObject_endloop[
		
		[?? edgeDetected] { //QUESTO SI VERIFICA SOLO QUANDO SI VA A SINISTRA E SI TROVA UN LEFTEDGE
			[!? leftEdge]	forward rover -m moveRover : cmd(move("right",40,750,1))
			else forward rover -m moveRover : cmd(move("left",40,750,1))
			
			
		}
		else {
			[not !? leftEdge] forward rover -m moveRover : cmd(move("right",40,750,1))
			else forward rover -m moveRover : cmd(move("left",40,750,1))
		}
		
	]
	switchTo stage1
	
	Plan stage2 
		actions []
		transition
			whenTime 60000 -> handleTout,
			whenEvent alarm -> handleAlarm,
			whenEvent sonarDetect -> stage2_manageObstacle, //SE QUESTO SCATTA: fixed or dynamic
			whenEvent robotControl -> handleControl
		finally repeatPlan
		
	Plan stage2_manageObstacle resumeLastPlan
		actions [
			forward rover -m moveRover : cmd(move("stop",40,0,1));
			forward rover -m moveRover : cmd(move("backward",20,2000,1))
		]
		transition
			whenTime 2000 -> stage2_manageObstacleDone,
			whenEvent alarm -> handleAlarm
	
	Plan stage2_manageObstacleDone resumeLastPlan
		actions [
			forward rover -m moveRover : cmd(move("stop",40,0,1))
		]
	
	Plan handleAlarm
		actions [
			printCurrentEvent;
			onEvent alarm : alarm(X) -> println("[rovermind] Alarm detected! Halted execution.")
		]
		
	Plan handleControl resumeLastPlan
		actions [
			printCurrentEvent;
			println("[rovermind] External control event! Halting");
			onEvent robotControl : robotControl(finish) -> endQActor "[rovermind] Finish event detected! Shutdown.";
			onEvent robotControl : robotControl(manual) -> {
				addRule manual;
				println("[rovermind] Switching to manual control plan...")
			}
		]
		switchTo [!? manual] stage2
	
	Plan handleTout resumeLastPlan
		actions []
}

QActor console context ctxRover4 {
	Plan init normal
		actions [
			println("Console started!")
		]
		switchTo handleCommands
	
	Plan handleCommands
		actions [
		
		]
		transition 
			whenTime 60000 -> handleTout,
			whenEvent cmd -> handleCmd,
			whenEvent inputcmd -> handleInputCmd,
			whenEvent [!? manual] usercmd -> handleUserCmd,
			whenEvent robotControl -> handleControl
		finally repeatPlan
		
	Plan handleCmd resumeLastPlan
		actions [
			onEvent cmd : cmd(start) -> {
				emit robotControl : robotControl(start)
			};
			onEvent cmd : cmd("stop") -> {
				addRule manual;
				emit robotControl : robotControl(manual)
			}
		]
	
	Plan handleUserCmd resumeLastPlan
		actions [
			onEvent usercmd : usercmd(robotgui(w(X))) -> forward rover -m moveRover : cmd(move("forward", 40, 0, 1));
			onEvent usercmd : usercmd(robotgui(a(X))) -> forward rover -m moveRover : cmd(move("left", 50, 750, 1));
			onEvent usercmd : usercmd(robotgui(s(X))) -> forward rover -m moveRover : cmd(move("backward", 40, 0, 1));
			onEvent usercmd : usercmd(robotgui(d(X))) -> forward rover -m moveRover : cmd(move("right", 50, 750, 1));
			onEvent usercmd : usercmd(robotgui(h(X))) -> forward rover -m moveRover : cmd(move("stop", 40, 0, 1));
			onEvent usercmd : usercmd(robotgui(X)) -> println(X)
		]
	
	Plan handleInputCmd resumeLastPlan
		actions [
			onEvent inputcmd : usercmd(executeInput(connectToUnity(X))) -> emit unityAddr : unityAddr(X) ;
			onEvent inputcmd : usercmd(executeInput(setStartDistance(X))) -> emit startDistance : startDistance(X);
			onEvent inputcmd : usercmd(executeInput(move(X,Y,Z))) -> forward rover -m moveRover : cmd(move(X,Y,Z));
			onEvent inputcmd : usercmd(executeInput(startReverse)) -> javaRun it.unibo.custom.path.startReverse() -asynch;
			onEvent inputcmd : usercmd(executeInput(X)) -> println(X)
		]
		
	Plan handleControl resumeLastPlan
		actions [
			onEvent robotControl : robotControl(finish) -> endQActor "[console] Finish alarm detected! Shutdown."
		]
		
	Plan handleTout resumeLastPlan
		actions []
}
