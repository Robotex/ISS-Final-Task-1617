/*
 * SONO PIAGA
 * STO LAVORANDO SU QUESTO FILE ATTUALMENTE PERCHE' STO FACENDO MOLTI ESPERIMENTI SUI RULES
 * LO TERRÒ IN CONSIDERAZIONE PER FUTURI AGGIORNAMENTI MA QUANDO SAPRÒ BENE COME FARE 
 * TORNO A LAVORARE SUL FILE DI PROGETTO PRINCIPALE
 */



System testRover2





 
 
Dispatch robotMoveLeft 		: robotMoveLeft(TIME)
Dispatch robotMoveRight 	: robotMoveRight(TIME)
Dispatch robotMoveForward	: robotMoveForward(TIME)
Dispatch robotMoveBackwards	: robotMoveBackwards(TIME)
Event robotHold 			: robotHold(SPEED,TIME)
Event inputcmd 				: usercmd(executeInput(CMD))
Event usercmd 				: usercmd(robotgui(X))
Event alarm 				: alarm(fire)
Event obstacle 				: obstacle(X)
Event cmd 					: cmd(X)
Event sonarDetect    		: sonarDetect(X)
Event sonar          		: sonar(SONAR, TARGET, DISTANCE)
   
 
  
Context  ctxRover2  ip [ host="localhost"  port=8070 ] -httpserver    
EventHandler evh for  sonarDetect , sonar,robotHold -print;   
 
QActor rover context ctxRover2{
	
	Plan loop normal[println("console ready")]
	transition stopAfter 60000
		whenEvent usercmd -> handleUserCmd,
		whenEvent inputcmd -> handleInputCmd,
		whenEvent cmd -> handleCmd,
		whenEvent alarm-> handleAlarm,
		whenEvent sonar-> handleSonar,
		whenEvent sonarDetect -> handleDetect
	finally repeatPlan 
	
	
	Plan connectToUnity resumeLastPlan[
		println("connection to unity requested");
		[!? unityOn] println("unity is connected yet")
	] switchTo [not !? unityOn] doConnectToUnity
	 
	Plan doConnectToUnity resumeLastPlan[
		println("connectingToUnity");
		onEvent inputcmd:usercmd(executeInput(connectToUnity(X)))-> actorOp workWithUnity(X);
		actorOp createSimulatedActor("rover","Prefabs/CustomActor");
		forward lowlevel -m robotMoveBackwards:robotMoveBackwards(1000);
		forward lowlevel -m robotMoveRight:robotMoveRight(1000);
		forward lowlevel -m robotMoveForward:robotMoveForward(1000);
		addRule unityOn
	]
		 
	Plan handleUserCmd resumeLastPlan[
		println("handling usercmd");
		onEvent usercmd : usercmd(robotgui(h(X))) -> emit robotHold:robotHold(X,1000);
		onEvent usercmd : usercmd(robotgui(w(X))) -> forward lowlevel -m robotMoveForward:robotMoveForward(1000);
		onEvent usercmd : usercmd(robotgui(s(X))) -> forward lowlevel -m robotMoveBackwards:robotMoveBackwards(1000);
		onEvent usercmd : usercmd(robotgui(a(X))) -> forward lowlevel -m robotMoveLeft:robotMoveLeft(1000);
		onEvent usercmd : usercmd(robotgui(d(X))) -> forward lowlevel -m robotMoveRight:robotMoveRight(1000)
		
	]
	
	Plan handleInputCmd resumeLastPlan[
		println("handling inputcmd");
		onEvent inputcmd:usercmd(executeInput(X)) -> println(X);
		onEvent inputcmd:usercmd(executeInput(connectToUnity(X))) ->{
			memoCurrentEvent; 
			addRule connectionRequest
		}
	]
	switchTo [?? connectionRequest] connectToUnity
	
	Plan handleCmd resumeLastPlan[
		onEvent cmd:X->println(X)
		
	]
	
	
	
	Plan handleDetect resumeLastPlan[
		println("handling detect from high");
		emit robotHold:robotHold(10,1000)
	]
	
	Plan handleSonar resumeLastPlan[
		actorOp assign(stage,1);
		println("handling sonar from high");
		onEvent sonar:sonar(sonar1,TARGET,DISTANCE) -> actorOp getVal(fcurrentDistance,DISTANCE);
		onEvent sonar:sonar(sonar2,TARGET,DISTANCE) -> actorOp assign(scurrentDistance,DISTANCE);
		[!? getVal(fcurrentDistance(D))] println(D);
		println("Taking stage value"); 
		
		
		
		[?? stage(0)] { //IN QUESTO STAGE IL ROVER RAGGIUNGE LA LINEA DI RILEVAMENTO DEL SONAR1
			println("stage0 Implemented - modified");
			onEvent sonar:sonar(sonar1,TARGET,DISTANCE) -> emit robotHold:robotHold(10,1000);
			addRule stage(1)
			
			
		};
		[!? stage(1)] { //IN QUESTO STAGE CI SI AVVICINA ALLO STARTING POINT
			
			println('stage 1');
			[!? fcurrentDistance(D)] actorOp eval(minus,50,D,R);
			[?? actorOpDone(OP,R)] println(done(OP,R));
			actorOp getDate;
			[!? actorOpDone(OP,R)] println(done(OP,R))
		}  
	]
	
	Plan handleAlarm[
		println("Alarm fired");
		emit robotHold:robotHold(50,1000)
	]
	
	Plan handleEnd[
		println('End of hl operation')
	]switchTo loop
	
	Plan handleTout[
		println('hl operation tout')
	]switchTo loop
	
	
}
 
QActor lowlevel context ctxRover2 {
	//INIZIA ED ASPETTA EVENTI O MESSAGGI
	
	Plan loop normal[
		println("lowlevel ready")
	]
	transition stopAfter 60000
		whenEvent sonarDetect->genericSonar,
		whenEvent robotHold:robotHold do println("I'm not doing anything"),
		whenMsg robotMoveLeft -> rotateLeft,
		whenMsg robotMoveRight -> rotateRight,
		whenMsg robotMoveForward -> moveForward,
		whenMsg robotMoveBackwards -> moveBackwards 
	finally repeatPlan
	

	//MUOVITI IN AVANTI
	Plan moveForward resumeLastPlan[
		println("Moving forward");
		addRule translation
	]
	reactive onward 30 time (1000)
		whenEnd -> endOfTranslation
		whenTout 100000-> handleTout
		whenEvent robotHold -> endOfMovement or
		whenEvent sonar -> genericSonar
	
	
	//MUOVITI INDIETRO
	Plan moveBackwards resumeLastPlan[
		println("Moving backwards");
		addRule translation
	]
	reactive backwards 30 time (1000)
		whenEnd -> endOfTranslation
		whenTout 100000-> handleTout
		whenEvent robotHold -> endOfMovement
		
	Plan rotateLeft resumeLastPlan[
		println("Rotating Left");
		left 50 time (1000)
	]
	
	Plan rotateRight resumeLastPlan[
		println("Rotating Right");
		right 50 time(1000)
	]
	
	Plan endOfTranslation resumeLastPlan[
		
		[?? translation] delay 10 
	]
	
		
	Plan endOfMovement[
		
		[?? translation] stop 0 time (1000)
		 
	]
	switchTo loop
	
	//PLAN GENERICO PER ERRORI GENERICI DI PROVA
	Plan genericSonar resumeLastPlan[println("WHAT?")]
	//PLAN GENERICO PER QUANDO FINISCE UNA REACTIVE
	Plan endOfWork resumeLastPlan[println("End of work")]
	
	//PLAN GENERICO PER UN TIMEOUTE DI UNA REACTIVE
	Plan handleTout resumeLastPlan[println("Time out")]
	//PLAN GENERICO PER L'ALLARME
	Plan handleAlarm resumeLastPlan[println("Alarm fired")] switchTo endOfMovement
}

