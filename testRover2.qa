/*
 * SONO PIAGA
 * STO LAVORANDO SU QUESTO FILE ATTUALMENTE PERCHE' STO FACENDO MOLTI ESPERIMENTI SUI RULES
 * TORNO A LAVORARE SUL FILE DI PROGETTO PRINCIPALE
 */



System testRover2



 
Dispatch robotMoveLeft 		: robotMoveLeft(TIME)
Dispatch robotRotateLeft	: robotRotateLeft(TIME)
Dispatch robotMoveRight 	: robotMoveRight(TIME)
Dispatch robotRotateRight	: robotRotateRight(TIME)
Dispatch robotMoveForward	: robotMoveForward(TIME)
Dispatch robotMoveBackwards	: robotMoveBackwards(TIME)

Event unityAddr				: unityAddr(ADDR)
Event robotHold 			: robotHold(SPEED,TIME)
Event inputcmd 				: usercmd(executeInput(CMD))
Event usercmd 				: usercmd(robotgui(X))
Event alarm 				: alarm(fire)
Event obstacle 				: obstacle(X)
Event cmd 					: cmd(X)
Event sonarDetect    		: sonarDetect(X)
Event sonar          		: sonar(SONAR, TARGET, DISTANCE)
   
 

Context  ctxRover2  ip [ host="localhost"  port=8070 ] -httpserver    
EventHandler evh for  robotHold {memoCurrentEvent for  rover};


QActor rover context ctxRover2 {
	//INIZIA ED ASPETTA EVENTI O MESSAGGI
	Rules{
		forTime(T).
	}
	
	Plan loop normal[
		println("lowlevel ready")
	]
	transition stopAfter 60000
		whenEvent unityAddr->doConnectToUnity,
		whenEvent robotHold:robotHold do println("I'm not doing anything"),
		whenMsg robotMoveForward -> moveForward,
		whenMsg robotMoveBackwards -> moveBackwards,
		whenMsg robotRotateLeft -> rotateLeft,
		whenMsg robotRotateRight -> rotateRight
	finally repeatPlan
	
	
	Plan doConnectToUnity resumeLastPlan[
		println("connectingToUnity");
		onEvent unityAddr:unityAddr(X)-> actorOp workWithUnity(X);
		actorOp createSimulatedActor("rover","Prefabs/CustomActor")
	]
	//onward [speed] time(time)

	//MUOVITI IN AVANTI
	Plan moveForward resumeLastPlan[
		println("Moving forward");
		addRule translation;
		onMsg robotMoveForward:robotMoveForward(T) -> addRule timing(T);
		[!? timing(T)] println(forwardTiming(T))
	]
	reactive [?? timing(T)] onward 25 time(T)
		whenEnd -> endOfMovement
		whenTout 100000-> handleTout
		whenEvent robotHold -> endOfMovement
		
	
	
	//MUOVITI INDIETRO
	Plan moveBackwards resumeLastPlan[
		println("Moving backwards");
		addRule translation;
		onMsg robotMoveBackwards:robotMoveBackwards(T) -> addRule timing(T);
		[!? timing(T)] println(backwardsTiming(T))
		
	]
	reactive [?? timing(T)]  backwards 30 time (T)
		whenEnd -> endOfStep
		whenTout 100000-> handleTout
		whenEvent robotHold -> endOfMovement
		
	Plan rotateLeft resumeLastPlan[
		println("Rotating Left");
		left 50 time (1000)
	] switchTo endOfStep
	
	Plan rotateRight resumeLastPlan[
		println("Rotating Right");
		right 50 time(1000)
	] switchTo endOfStep
	
	/*Plan moveLeft resumeLastPlan[
		println("Moving left");
		left 50 time(1000);
		addRule leftMovement;
		addRule translation
	] switchTo moveForward
	
		
	Plan moveRight resumeLastPlan[
		println("Moving right");
		right 50 time(1000);
		addRule rightMovement;
		addRule translation
	] switchTo moveForward
	*/
	
	
	Plan endOfStep resumeLastPlan[
		
		[?? translation] delay 100
	]
	
		
	Plan endOfMovement[
		onEvent robotHold:X -> println("robot hold called");
		stop 100 time (10);
		[?? leftMovement] right 50 time(1000);
		[?? rightMovement] left 50 time(1000)
		
		 
	]
	switchTo loop
	
	//PLAN GENERICO PER ERRORI GENERICI DI PROVA
	Plan genericSonar resumeLastPlan[println("WHAT?")]
	//PLAN GENERICO PER QUANDO FINISCE UNA REACTIVE
	Plan endOfWork resumeLastPlan[println("End of work")]
	
	//PLAN GENERICO PER UN TIMEOUTE DI UNA REACTIVE
	Plan handleTout resumeLastPlan[println("Time out")]
	//PLAN GENERICO PER L'ALLARME
	Plan handleAlarm resumeLastPlan[println("Alarm fired")] switchTo endOfMovement
}   
 
QActor highlevel context ctxRover2{
	
	Rules{
		
		status:- stage(S).
		r2:-startingDistance(S),fCurrentDistance(F),eval(minus,S,F,RV),assert(difference(RV)).
		r3:- difference(DFF).
	}
	
	Plan init normal[
		
	] switchTo loop
	 
	Plan loop [
		/*addRule startingDistance(400);
		addRule fCurrentDistance(200);
		addRule sCurrentDistance(300);
		[!? startingDistance(S)] demo assign(x,S);
		[!? fCurrentDistance(F)] demo assign(y,F);
		demo getVal(x,V1);
		demo getVal(y,V2);
		[!? goalResult(getVal(x,V1))] println(V1);
		[?? goalResult(getVal(y,V2))] println(V2);
		addRule difference(100,200);
		demo r2;
		demo r3;
		[!? difference(S,F)] demo eval(minus,S,F,RV);
		[!? goalResult(eval(minus,S,F,RV))] println(result(RV));*/
		/*addRule startingDistance(30);
		addRule fCurrentDistance(15);
		addRule difference(10);
		demo r2;
		[?? difference(DFF)] println(difference(DFF)) else println("nodiff");
		[!? difference(DFF)] println(difference(DFF)) else println("nodiff");
		[!? difference(0)] println("0 true") else println("0 false");
		[!? difference(15)] println("15 true") else println("15 false");
		[!? difference(DD)] demo eval(gt,DD,0);
		[!? goalResult(eval(gt,DD,0))] println('true') else println('false');
		
		*/
		//demo r2;
		
		[!? stage(0)]{
			println("yeah");  //se si entra in questa fase ci si aspetta che il rover esista
			[!? approachToLine] {
				println("loop stage(0)");	
				println("Unity is connected so....i'm taking position");
				forward rover -m robotMoveBackwards:robotMoveBackwards(2000);
				delay 2500;
				forward rover -m robotRotateRight:robotRotateRight(1000);
				delay 1500;
				forward rover -m robotMoveForward:robotMoveForward(8000)
			}
		};
		[!? stage(1)]{
			
			[!? difference(DFF)]{
				
				[?? approachToPoint] {
					println("Approaching to point");
					[!? difference(DFF)] println(evaluationOn(DFF));
					[!? difference(DFF)] demo eval(lt,DFF,0);
					[!? goalResult(eval(lt,DFF,0))] println(true(DFF)) else println(false(DFF)); 
					[!? goalResult(eval(lt,DFF,0))] {
						addRule getClose;
						forward rover -m robotRotateLeft : robotRotateLeft(1000);
						forward rover -m robotMoveForward:robotMoveForward(10000);						
						forward rover -m robotRotateRight:robotRotateRight(1000)
					}
					else {
						addRule getFar;
						forward rover -m robotRotateRight:robotRotateRight(1000);
						forward rover -m robotMoveForward:robotMoveForward(10000);
						forward rover -m robotRotateLeft:robotRotateLeft(1000)
					}
				}
			}	
		};
		[!? stage(2)]{
			[?? detection]{
				forward rover -m robotMoveBackwards:robotMoveBackwards(1000);
				delay 1000;
				[!? rightDeviation] {
					println("rover need to deviate to right");
					forward rover -m robotRotateRight:robotRotateRight(1000);
					delay 1000;
					forward rover -m robotMoveForward:robotMoveForward(2000);
					forward rover -m robotRotateLeft:robotRotateLeft(1000)
					
				};
				[!? leftDeviation] {
					println("rover need to deviate to left");
					forward rover -m robotRotateLeft:robotRotateLeft(1000);
					delay 1000;
					forward rover -m robotMoveForward:robotMoveForward(2000);
					forward rover -m robotRotateRight:robotRotateRight(1000)
					
				}
			};
			
			[?? arrivingLine] {
				[?? leftDeviation] delay 7000;
				[?? rightDeviation] delay 7000;
				[?? frontObstacle] delay 7000;
				println("stage2 moveforward");
				
				forward rover -m robotMoveForward:robotMoveForward(20000)
			}
		}
		
	]
	transition stopAfter 60000
		whenEvent usercmd -> handleUserCmd,
		whenEvent inputcmd -> handleInputCmd,
		whenEvent cmd -> handleCmd,
		whenEvent alarm-> handleAlarm,
		whenEvent sonar-> handleSonar,
		whenEvent sonarDetect -> handleDetect
	finally repeatPlan
	
	
	Plan approachingToStartingPoint[
		 
	] 
	transition stopAfter 60000
		whenEvent alarm -> handleAlarm,
		whenEvent sonar -> handleSonar
	finally repeatPlan
	
	
	 
	
		 
	Plan handleUserCmd resumeLastPlan[
		println("handling usercmd");
		onEvent usercmd : usercmd(robotgui(h(X))) -> emit robotHold:robotHold(X,1000);
		onEvent usercmd : usercmd(robotgui(w(X))) -> forward rover -m robotMoveForward:robotMoveForward(1000);
		onEvent usercmd : usercmd(robotgui(s(X))) -> forward rover -m robotMoveBackwards:robotMoveBackwards(1000);
		onEvent usercmd : usercmd(robotgui(a(X))) -> forward rover -m robotRotateLeft:robotMoveLeft(1000);
		onEvent usercmd : usercmd(robotgui(d(X))) -> forward rover -m robotRotateRight:robotMoveRight(1000)
		
	]
	
	Plan handleInputCmd resumeLastPlan[
		println("handling inputcmd");
		onEvent inputcmd:usercmd(executeInput(X)) -> println(X);
			onEvent inputcmd:usercmd(executeInput(connectToUnity(X))) -> emit unityAddr:unityAddr(X);
			addRule stage(0); //NEL MOMENTO IN CUI VIENE CHIAMATO IL PLAN DI CONNESSIONE E CREAZIONE SI COMINCIA CON IL PRIMO STAGE
			addRule approachToLine //SI DA PERMESSO AL ROVER DI POSIZIONARSI DAVANTI ALLA LINEA DI SONAR1
		};
			onEvent inputcmd:usercmd(executeInput(startingDistance(X))) -> addRule startingDistance(X);
			[!? startingDistance(X)] addRule approachToPoint
		} 
	]
	
	
	
	Plan handleCmd resumeLastPlan[
		onEvent cmd:X->println(X);
		[!? stage(2)] onEvent cmd:cmd(start) ->{
			addRule arrivingLine
		}
		
	]
	
	
	/*
	 * per valutare i movimenti successivi al rover basta una sola segnalazione
	 * motivo per cui si fa utilizzo di una regola detection
	 */
	Plan handleDetect resumeLastPlan[
		println("handling detect from high");
		[!? stage(2)]{
			[not !? detection] {
				forward rover -m robotHold:robotHold(100,10);
				
				addRule detection;
				//onEvent sonarDetect:sonarDetect(X) -> addRule object(X);				
				onEvent sonarDetect:sonarDetect(pillar1) -> addRule rightDeviation;
				onEvent sonarDetect:sonarDetect(pillar2) -> addRule leftDeviation;
				onEvent sonarDetect:sonarDetect(dynamicobstacle) -> addRule frontObstacle;
				addRule arrivingLine
			}	
		}
	]
	
		//println("handling sonar from high");
		/*
		 * Premessa, se handleSonar viene chiamato, certamente esiste un rover in mappa
		 * handleSonar viene chiamato quando il sonar1 o il sonar2 rilevano rover davanti a se
		 * quindi la seguente guardia [!? stage(0)] viene chiamato quando sonar1 rileva rover
		 * e ha raggiunto quindi la linea di rilevamento di partenza passando quindi allo stage(1)
		 */
		//[!? stage(S)] println(stage(S));
		[!? stage(0)]{ // SI AVVICINA ALLA LINEA
			[?? approachToLine]{
				forward rover -m robotHold:robotHold(100,1000);
				[?? stage(0)] addRule stage(1)
			}
		};
		
		/*
		 * Dallo stage(0) allo stage(1) handleSonar viene chiamato di continuo
		 * Va considerato quindi come un tick ad update
		 */
		[!? stage(1)]{ //SI PORTA AL PUNTO DI PARTENZA
			removeRule fCurrentDistance(F);
			removeRule difference(DFF);
			onEvent sonar:sonar(SONAR,TARGET,DISTANCE) -> addRule fCurrentDistance(DISTANCE);
			onEvent sonar:sonar(SONAR,TARGET,DISTANCE) -> addRule sonarName(SONAR);
			
			
			demo r2;
			[!? difference(DFF)] println(snrDifference(DFF));
			[!? getClose] {
				
				[!? difference(DFF)] demo eval(gt,DFF,0);
				[?? goalResult(eval(gt,DFF,0))]{
					 
					forward rover -m robotHold:robotHold(100,10);
					[?? sonarName(sonar1)]{ 
						[?? stage(1)] addRule stage(2)
					} else
					{
						println("End of the journey");
						removeRule stage(1)
					}	
				}
			};
			[!? getFar] {
				[!? difference(DFF)] demo eval(lt,DFF,0);
				[?? goalResult(eval(lt,DFF,0))]{ 
					forward rover -m robotHold :robotHold(100,10);
					[?? sonarName(sonar1)]{ 
						[?? stage(1)] addRule stage(2)
					}  else
					{
						println("End of the journey");
						removeRule stage(1)
					}		
				}
			}
		};
		/*
		 * Lo stage 2 riguarda solo il sonar2.
		 * Questo evento viene sparato solamente quando il rover raggiunge l'altra linea
		 */
		[!? stage(2)]{
			onEvent sonar:sonar(sonar2,TARGET,DISTANCE) -> {
				println("Rover arriving at line of sonar2");
				removeRule fCurrentDistance(F);
				removeRule difference(DFF);
				forward rover -m robotHold:robotHold(100,10);
				addRule approachToPoint;
				[?? stage(2)] addRule stage(1)
			}
		}
 
	]
	
	
	Plan handleAlarm[
		println("Alarm fired");
		emit robotHold:robotHold(50,1000)
	
	Plan handleEnd[
		println('End of hl operation')
	]switchTo loop
	
	Plan handleTout[
		println('hl operation tout')
	]switchTo loop
	
	
}
 

